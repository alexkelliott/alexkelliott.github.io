#include <stdio.h>
#include <stdlib.h>
#include "gba.h"
#include "game.h"
// #include "DMA.h"
                    /* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/startPic.h"
#include "images/losePic.h"
#include "images/space.h"
#include "images/applePic.h"
#include "images/clockPic.h"


                    /* TODO: */
// Add any additional states you need for your app.
typedef enum {
    START,
    PLAY,
    WIN,
    LOSE,
} GBAState;

void render(Snake *snake, Node *apple, Node *clock);
void init(Snake *snake, Node *apple, Node *clock);
void plotApple(Snake *snake, Node *apple, Node *clock);
int hitApple(Snake *snake, Node *apple);
int collision(Snake *snake);
void plotClock(Snake *snake, Node *apple, Node *clock);
int hitClock(Snake *snake, Node *clock);

int main(void) {
                    /* TODO: */
    // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;

    // Save current and previous state of button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    // Load initial game state
    GBAState state = START;

    //initialize pointers
    Snake s;
    Snake* snake = &s;
    Node a;
    Node* apple = &a;
    Node c;
    Node* clock = &c;
    

    int wait = 0;

    char buffer1[51];

    u16 pallette[] = {RED, GREEN, BLUE, WHITE, MAGENTA, YELLOW, CYAN};

    while (1) {
        currentButtons = BUTTONS; // Load the current state of the buttons

        switch(state) {
            case START:
                waitForVBlank();
                drawFullScreenImageDMA(startPic);
                if (KEY_DOWN(BUTTON_START, currentButtons)) {
                    state = PLAY;
                    init(snake, apple, clock);
                }
                break;

            case PLAY:
                //check if they want to go back to the title screen
                if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
                    state = START;
                    break;
                } 

                //change snake direction
                if (KEY_DOWN(BUTTON_UP, currentButtons)) {
                    if (snake->length > 1 && snake->headDir == SOUTH) {
                        state = LOSE;
                        drawFullScreenImageDMA(losePic);
                    } else {
                        snake->headDir = NORTH;
                    }
                } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
                    if (snake->length > 1 && snake->headDir == WEST) {
                        state = LOSE;
                        drawFullScreenImageDMA(losePic);
                    } else {
                        snake->headDir = EAST;
                    }
                } else if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
                    if (snake->length > 1 && snake->headDir == NORTH) {
                        state = LOSE;
                        drawFullScreenImageDMA(losePic);
                    } else {
                        snake->headDir = SOUTH;
                    }
                } else if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
                    if (snake->length > 1 && snake->headDir == EAST) {
                        state = LOSE;
                        drawFullScreenImageDMA(losePic);
                    } else {
                        snake->headDir = WEST;
                    }
                }

                // slow down the snake, bigger num -> slower snake
                wait++;
                if (wait < snake->speed)
                    break;
                wait = 0;

                // increase speed as time goes on
                if (snake->speed > 3250) snake->speed -= 50;

                // determine where the new snake piece goes and put it in the array
                int newIndex = (snake->head + 1) % MAX_SNAKE_LENGTH;
                if (snake->headDir == NORTH) {
                    snake->pieces[newIndex].x = snake->pieces[snake->head].x;
                    snake->pieces[newIndex].y = snake->pieces[snake->head].y -= 1;
                } else if (snake->headDir == EAST) {
                    snake->pieces[newIndex].x = snake->pieces[snake->head].x += 1;
                    snake->pieces[newIndex].y = snake->pieces[snake->head].y;
                } else if (snake->headDir == SOUTH) {
                    snake->pieces[newIndex].x = snake->pieces[snake->head].x;
                    snake->pieces[newIndex].y = snake->pieces[snake->head].y += 1;
                } else { // WEST
                    snake->pieces[newIndex].x = snake->pieces[snake->head].x -= 1;
                    snake->pieces[newIndex].y = snake->pieces[snake->head].y;
                }

                snake->pieces[newIndex].color = pallette[rand()%(sizeof(pallette)/sizeof(u16))];

                snake->head = newIndex;

                if (collision(snake)) {
                    //end the game
                    state = LOSE;
                    drawFullScreenImageDMA(losePic);
                    break;
                }

                // check for win
                if (snake-> length >= 20) {
                    state = WIN;
                    drawFullScreenImageDMA(losePic);
                    break;
                }

                waitForVBlank();
                render(snake, apple, clock);

                if (hitApple(snake, apple)) {
                    plotApple(snake, apple, clock);
                    snake->length++;
                } else {
                    snake->tail = (snake->tail + 1) % MAX_SNAKE_LENGTH;
                }

                if (hitClock(snake, clock)) {
                    snake->speed += 3000;
                    plotClock(snake, apple, clock);
                }
                
                break;
            case WIN:
                waitForVBlank();
                sprintf(buffer1, "VICTORY!");
                drawCenteredString(0, 20, WIDTH, 20, buffer1, GREEN);
                sprintf(buffer1, "SCORE: %d", snake->length);
                drawCenteredString(0, 50, WIDTH, 20, buffer1, GREEN);
                sprintf(buffer1, "PRESS ENTER TO RESTART");
                drawCenteredString(0, 80, WIDTH, 20, buffer1, GREEN);

                if (KEY_DOWN(BUTTON_START, currentButtons)) {
                    state = PLAY;
                    init(snake, apple, clock);
                }
                //check if they want to go back to the title screen
                if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
                    state = START;
                }

                break;
            case LOSE:
                waitForVBlank();
                sprintf(buffer1, "GAME OVER");
                drawCenteredString(0, 20, WIDTH, 20, buffer1, RED);
                sprintf(buffer1, "SCORE: %d", snake->length);
                drawCenteredString(0, 50, WIDTH, 20, buffer1, RED);
                sprintf(buffer1, "PRESS ENTER TO RESTART");
                drawCenteredString(0, 80, WIDTH, 20, buffer1, RED);

                if (KEY_DOWN(BUTTON_START, currentButtons)) {
                    state = PLAY;
                    init(snake, apple, clock);
                }
                //check if they want to go back to the title screen
                if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
                    state = START;
                    drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK); // replace with background
                } 
                break;
        }
    }

    UNUSED(previousButtons);
    return 0;
}

void init(Snake *snake, Node *apple, Node *clock) {
    /* Initialize the snake */
    snake->speed = 15000;
    snake->length = 1;

    snake->head = 1;
    snake->pieces[snake->head].x = 5;
    snake->pieces[snake->head].y = 5;

    snake->tail = 0;
    snake->pieces[snake->tail].x = 5;
    snake->pieces[snake->tail].y = 5;


    snake->headDir = EAST;
    snake->blockSize = 10;
    int bs = snake->blockSize;

    //save the pixels behind the snake pieces
    saveBackground(snake->pieces[snake->head].x * bs,
        snake->pieces[snake->head].y * bs,
        snake->pieces[snake->head].restore,
        space);
    saveBackground(snake->pieces[(snake->tail+1)%MAX_SNAKE_LENGTH].x * bs,
        snake->pieces[(snake->tail+1)%MAX_SNAKE_LENGTH].y * bs,
        snake->pieces[snake->tail].restore,
        space);

    drawFullScreenImageDMA(space);
    plotApple(snake, apple, clock);
    plotClock(snake, apple, clock);
    render(snake, apple, clock);
}

void plotApple(Snake *snake, Node *apple, Node *clock) {
    int bs = snake->blockSize;
    while (1) {
        //make sure that its on the screen
        apple->x = rand() % (WIDTH / bs);
        apple->y = rand() % ((HEIGHT / bs) - 2);

        int match = 0;
        //make sure its not on the clock
        if (apple->x == clock->x &&
            apple->y == clock->y) {
            match = 1;
            continue;
        }


        //make sure that its not on the snake
        for (int i = 0; i < snake->length - 1; i++) {
            int index = (i + snake->tail) % MAX_SNAKE_LENGTH;
            if (snake->pieces[index].x == apple->x &&
                snake->pieces[index].y == apple->y) {
                match = 1;
                break;
            }
        }
        if (!match)
            break;
    }
}

int hitApple(Snake *snake, Node *apple) {
    int sx = snake->pieces[snake->head].x;
    int sy = snake->pieces[snake->head].y;
    if (sx == apple->x && sy == apple->y) {
        int bs = snake->blockSize;
        drawRectDMA(sx * bs, sy * bs, bs-1, bs-1, snake->pieces[snake->head].color);
        return 1;
    }
    return 0;
}

int collision(Snake *snake) {
    //collision with the boundaries
    if (snake->pieces[snake->head].x < 0 ||
        snake->pieces[snake->head].x >= (WIDTH/snake->blockSize) ||
        snake->pieces[snake->head].y < 0 ||
        snake->pieces[snake->head].y >= (HEIGHT/snake->blockSize) - 1)
        return 1;

    //collision with the snake
    for (int i = 0; i < snake->length - 1; i++) {
        int index = (i + snake->tail) % MAX_SNAKE_LENGTH;
        if (snake->pieces[index].x == snake->pieces[snake->head].x &&
            snake->pieces[index].y == snake->pieces[snake->head].y)
            return 1;
    }

    return 0;

}

void plotClock(Snake *snake, Node *apple, Node *clock) {
    int bs = snake->blockSize;
    while (1) {
        //make sure that its on the screen
        clock->x = rand() % (WIDTH / bs);
        clock->y = rand() % ((HEIGHT / bs) - 2);

        int match = 0;
        //make sure its not on the apple
        if (apple->x == clock->x &&
            apple->y == clock->y) {
            match = 1;
            continue;
        }

        //make sure that its not on the snake
        for (int i = 0; i < snake->length - 1; i++) {
            int index = (i + snake->tail) % MAX_SNAKE_LENGTH;
            if (snake->pieces[index].x == clock->x &&
                snake->pieces[index].y == clock->y) {
                match = 1;
                break;
            }
        }
        if (!match)
            break;
    }
}

int hitClock(Snake *snake, Node *clock) {
    int sx = snake->pieces[snake->head].x;
    int sy = snake->pieces[snake->head].y;
    if (sx == clock->x && sy == clock->y) {
        int bs = snake->blockSize;
        drawRectDMA(sx * bs, sy * bs, bs-1, bs-1, snake->pieces[snake->head].color);
        return 1;
    }
    return 0;
}

void render(Snake *snake, Node *apple, Node *clock) {
    int bs = snake->blockSize;

    //draw apple
    drawImageDMA(apple->y * bs, apple->x * bs, 9, 9, applePic);

    //draw clock
    drawImageDMA(clock->y * bs, clock->x *bs, 9, 9, clockPic);

    //save the background behind the head
    saveBackground(snake->pieces[snake->head].x * bs,
        snake->pieces[snake->head].y * bs,
        snake->pieces[snake->head].restore,
        space);

    //draw snake
    drawRectDMA(snake->pieces[snake->head].x * bs,
        snake->pieces[snake->head].y * bs,
        bs-1,
        bs-1,
        snake->pieces[snake->head].color);
    

    //redraw the background behind the tail
    replaceBackground(snake->pieces[snake->tail].x * bs,
        snake->pieces[snake->tail].y * bs,
        snake->pieces[(snake->tail+1)%MAX_SNAKE_LENGTH].restore);


    // draw score
    char buffer[51];
    drawRectDMA(70, 150, 100, 10, BLACK); // black out the background
    sprintf(buffer, "Score: %d", snake->length);
    drawCenteredString(0, 145, WIDTH, 20, buffer, WHITE);
}